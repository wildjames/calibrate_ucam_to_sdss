You gotta do some stuff.


1. Reductions. 

    You'll need three reductions, for a run;
        a. Standard star reduction - large apertures to capture all the light of the star. Don't use optimal reductions!
        b. A reduction in the target field, that uses the SAME settings as a. that we can use to find the magnitudes of the comparison star(s)
        c. The target field, with optimised reduction settings, i.e. good SNR on the target.


2. Gather some data

    I've pre-calculated the colour term gradients. We want to use an equation of this kind of form:

    g_sdss = g_inst - g_zp - k_ext*X - a_g(g-r)

    i.e. atmospheric correction applied, colour term accounted for. The file FOUND_VALUES.json contains a_ugr values, calculated from sythetic spectra. This is generated by the script generate_colour_term_corrections.py.


3. Calculate zero points

    The colour terms above are fine, but since they're calculated from surface fluxes (and synthetic...) we don't really want to use them for zero points. Use the script calculate_zero_points.py to extract this from your standard star reduction. This adds the zero points to the FOUND_VALUES.json file, too.


4. Calculate SDSS magnitudes for the comparison stars

    The instrumental magnitudes of the comparison stars can be converted to SDSS magnitudes now. This is done with the script calculate_comparison_magnitudes.py.

5. Flux calibrate the target

    